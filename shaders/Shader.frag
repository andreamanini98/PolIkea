#version 450#extension GL_ARB_separate_shader_objects : enable#define N_SPOTLIGHTS 50#define N_POINTLIGHTS 50layout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec2 fragUV;layout(location = 0) out vec4 outColor;struct SpotLight {    float beta;   // decay exponent of the spotlight    float g;      // target distance of the spotlight    float cosout; // cosine of the outer angle of the spotlight    float cosin;  // cosine of the inner angle of the spotlight    vec3 lightPos;    vec3 lightDir;    vec4 lightColor;};struct PointLight {    float beta;   // decay exponent of the spotlight    float g;      // target distance of the spotlight    vec3 lightPos;    vec4 lightColor;};layout(set = 0, binding = 0) uniform GlobalUniformBufferObject {    vec3 DlightDir;     // direction of the direct light    vec3 DlightColor;   // color of the direct light    vec3 AmbLightColor; // ambient light    vec3 eyePos;        // position of the viewer    SpotLight spotLights[N_SPOTLIGHTS];    PointLight pointLights[N_POINTLIGHTS];    int nSpotLights;    int nPointLights;} gubo;layout(set = 1, binding = 0) uniform UniformBufferObject {    float amb;    float gamma;    vec3 sColor;    mat4 mvpMat;    mat4 mMat;    mat4 nMat;} ubo;layout(set = 1, binding = 1) uniform sampler2D tex;void main() {    vec3 N = normalize(fragNorm);              // surface normal    vec3 EyeDir = normalize(gubo.eyePos - fragPos); // viewer direction    vec3 albedo = texture(tex, fragUV).rgb;    // main color    vec3 MD = albedo*0.95f;    vec3 MS = ubo.sColor;    vec3 MA = albedo * ubo.amb;    vec3 LA = gubo.AmbLightColor;    // Lambert    vec3 f_diffuse_DIRECT = MD * max(dot(gubo.DlightDir, N), 0.0f);    // Blinn    vec3 f_specular_DIRECT = MS * pow(clamp(dot(N, normalize(gubo.DlightDir + EyeDir)), 0.0f, 1.0f), ubo.gamma);    vec3 BRDF_DIRECT = f_diffuse_DIRECT + f_specular_DIRECT;    vec3 sl = vec3(0.0f, 0.0f, 0.0f);    for (int i = 0; i < gubo.nSpotLights; i++) {        vec3 spotLightDir = normalize(gubo.spotLights[i].lightPos - fragPos);        // Lambert        vec3 f_diffuse_SPOT = MD * max(dot(spotLightDir, N), 0.0f);        // Blinn        vec3 f_specular_SPOT = MS * pow(clamp(dot(N, normalize(spotLightDir + EyeDir)), 0.0f, 1.0f), ubo.gamma);        //BRDF * SPOTLIGHT_LIGHT_MODEL        sl = sl + (f_diffuse_SPOT + f_specular_SPOT) * (gubo.spotLights[i].lightColor.rgb *                  (pow(gubo.spotLights[i].g / length(gubo.spotLights[i].lightPos - fragPos), gubo.spotLights[i].beta)) *                  clamp(((dot(normalize(gubo.spotLights[i].lightPos - fragPos), gubo.spotLights[i].lightDir)) - gubo.spotLights[i].cosout) /                         (gubo.spotLights[i].cosin - gubo.spotLights[i].cosout), 0.0f, 1.0f));    }    vec3 pl = vec3(0.0f, 0.0f, 0.0f);    for (int i = 0; i < gubo.nPointLights; i++) {        vec3 pointLightDir = normalize(gubo.pointLights[i].lightPos - fragPos);        // Lambert        vec3 f_diffuse_POINT = MD * max(dot(pointLightDir, N), 0.0f);        // Blinn        vec3 f_specular_POINT = MS * pow(clamp(dot(N, normalize(pointLightDir + EyeDir)), 0.0f, 1.0f), ubo.gamma);        //BRDF * POINTLIGHT_LIGHT_MODEL        pl = pl + (f_diffuse_POINT + f_specular_POINT) *                  (gubo.pointLights[i].lightColor.rgb *                  (pow(gubo.pointLights[i].g / length(gubo.pointLights[i].lightPos - fragPos), gubo.pointLights[i].beta)));    }    outColor = vec4(clamp(BRDF_DIRECT*LA + sl + pl + MA, 0.0f, 1.0f), 1.0f);}